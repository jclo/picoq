/*! ****************************************************************************
 * PicoQ v1.0.3
 *
 * A tiny Javascript library to interact with the DOM.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2024 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * Built from ES6Kadoo v2.1.0.
 * ************************************************************************** */
/*! Generated by Kadoo v1.2.0 */
// ESLint declarations
/* global define */
/* eslint no-shadow: ['error', { 'allow': ['root'] }] */
/* eslint strict: ["error", "function"] */
(function(root, factory) {
  'use strict';

  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([''], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    /* eslint-disable-next-line no-param-reassign */
    module.exports = factory(root);
  } else {
    // Browser globals.
    /* eslint-disable-next-line no-param-reassign */
    root.PicoQ = factory(root);
  }
}(this, (root) => {
  'use strict';

  /* ***************************************************************************
   *
   * Tree is an object that links all the internal IIFE modules.
   *
   * ************************************************************************ */
  /* eslint-disable */
  let $__TREE = {"src":{"picoq":{},"private":{"animate":{},"fetch":{},"diffing":{}}}};
  $__TREE.extend=function(o,m){var k=Object.keys(m);for(var i=0;i<k.length;i++){o[k[i]]=m[k[i]]}};
  /* - */
  /* eslint-enable */

  /* index: 1, path: 'src/picoq.js', import: [2, 3, 4] */
  (function() {
    /** ************************************************************************
     *
     * Implements the methods to manipulate the DOM.
     *
     * picoq.js is built upon the Prototypal Instantiation pattern. It
     * returns an object by calling its constructor. It doesn't use the new
     * keyword.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . PicoQ                       creates and returns the PicoQ object,
     *
     *
     * Private Static Methods:
     *  . _setTestMode                returns internal objects for testing purpose,
     *
     *
     * Public Static Methods:
     *  . noConflict                  returns a reference to this PicoQ object,
     *  . fetch                       fetches data on the server,
     *  . get                         retrieves a text file from the server,
     *  . getJSON                     retrieves a JSON file from the server,
     *  . post                        sends a request to the server,
     *
     *
     * Public Variables:
     *  . [0]                         the selected DOM element,
     *  . _library                    the name and version of the library,
     *  . _root                       the first parent DOM element,
     *  . id                          the id of selected element,
     *
     *
     * Public Methods:
     *  . whoami                      returns the library name and version,
     *
     *  . select                      selects a child element,
     *  . selectChild                 selects the nth child,
     *  . parent                      returns to the parent element,
     *  . firstParent                 returns to the root parent if defined,
     *  . find                        returns the NodeList of the matching children,
     *  . tag                         returns the tag name of the selected element,
     *
     *  . html                        gets/sets the HTML contents of the element,
     *  . empty                       removes all the childs from the current node,
     *
     *  . append                      appends and selects a node, defined by an HTML tag,
     *  . appendTextChild             appends a text node child to the selected node,
     *  . appendBefore                appends and selects a node before the selected node,
     *  . appendAfter                 appends and selects a node after the selected node,
     *  . replace                     replaces the current node by a new node,
     *
     *  . appendHTML                  appends an HTML string after the last child,
     *  . prepend                     appends an HTML string before the first child,
     *  . after                       appends an HTML string after the current node,
     *  . before                      appends an HTML string before the current node,
     *  . replaceWith                 replaces the current node with the given DOMString,
     *
     *  . diff                        updates the node to match the passed-in template,
     *
     *  . text                        gets/sets the text contents of the element,
     *
     *  . clone                       clones the selected element,
     *  . firstChild                  returns the firstChild element,
     *  . insertChildBefore           inserts a child element before another child element,
     *  . removeChild                 removes the passed-in child element,
     *  . replaceChild                replaces a child by another,
     *  . children                    returns the children,
     *  . childIndex                  returns the children position in the parent tree,
     *  . getRect                     returns the DOMRect object that bounds,
     *
     *  . css                         gets/sets the style attribute of the element,
     *
     *  . getClassList                returns the DOMTokenList collection,
     *  . addClass                    adds a class name to the element,
     *  . addClasses                  adds a list of classes to the element,
     *  . removeClass                 removes a class name from the element,
     *  . removeClasses               removes a list of classes from the element,
     *  . toggleClass                 toggles a class name for the element,
     *  . hasClass                    checks if the element has the passed-in class,
     *
     *  . attr                        sets or gets the specified attribute,
     *  . removeAttr                  removes the specified attribute,
     *
     *  . animate                     performs an animation,
     *
     *  . on                          attachs an event listener to the current node,
     *  . off                         removes an event listener from the current node,
     *  . trigger                     fires the event associated to the selected node,
     *  . fire                        aliases the 'trigger' method,
     *
     *  . load                        retrieves an XMLString and add it into the DOM,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const Anim = $__TREE.src.private.animate;
    const F = $__TREE.src.private.fetch;
    const D = $__TREE.src.private.diffing;


    // -- Local Constants
    // Saves the previous value of the library variable, so that it can be
    // restored later on, if noConflict is used.
    const previousPicoQ = root.PicoQ
        ;


    // -- Local Variables
    let methods;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the PicoQ object.
     * (Prototypal Instantiation Pattern)
     *
     * @constructor (arg1)
     * @public
     * @param {String}          the DOM selector,
     * @returns {Object}        returns the PicoQ object,
     * @since 0.0.0
     */
    const PicoQ = function(selector) {
      // If the parent has a defined 'id'. We starts exploring the DOM
      // from this 'id'. And, the node with this 'id' becomes the root parent.
      const cid = this && this.id ? `#${this.id}` : 'body';

      const obj = Object.create(methods);
      obj._library = {
        name: 'PicoQ',
        version: '1.0.3',
      };

      obj._root = cid !== 'body' ? document.querySelector(cid) : undefined;

      // Selects the first element that matches the selector(s)
      // or selects the entire 'web component':
      obj[0] = selector
        ? document.querySelector(cid).querySelector(selector)
        : document.querySelector(cid);

      obj.id = obj[0] ? obj[0].id : null;

      return obj;
    };

    // Attaches constants to PicoQ that provide name and version of the lib.
    PicoQ.NAME = 'PicoQ';
    PicoQ.VERSION = '1.0.3';


    // -- Private Static Methods -----------------------------------------------

    /**
     * Returns the internal objects for testing purpose.
     * (must not be deleted)
     *
     * @method ()
     * @private
     * @param {}                -,
     * @returns {Object}        returns a list of internal objects,
     * @since 0.0.0
     */
    PicoQ._setTestMode = function() {
      return [F, D];
    };


    // -- Public Static Methods ------------------------------------------------

    /**
     * Returns a reference to this PicoQ object.
     * (must not be deleted)
     *
     * Nota:
     * Running PicoQ in noConflict mode, returns the PicoQ variable to
     * its previous owner.
     *
     * @method ()
     * @public
     * @param {}                -,
     * @returns {Object}        returns the PicoQ object,
     * @since 0.0.0
     */
    PicoQ.noConflict = function() {
      /* eslint-disable-next-line no-param-reassign */
      root.PicoQ = previousPicoQ;
      return this;
    };

    /**
     * Fetches data on the server.
     *
     * @method (arg1, [arg2], [arg3], [arg4])
     * @public
     * @param {String}        the server url,
     * @param {Object}        the fetch options,
     * @param {String}        the type of file (json or text),
     * @param {String}        the function to call at the completion,
     * @returns {Object}      returns a promise,
     * @since 0.0.0
     */
    PicoQ.fetch = function(...args) {
      return F.fetch(...args);
    };

    /**
     * Retrieves a text file from the server.
     *
     * @method (arg1, [arg2], [arg3], [arg4])
     * @public
     * @param {String}        the server url,
     * @param {Object}        the fetch options,
     * @param {String}        the type of file (json or text),
     * @param {String}        the function to call at the completion,
     * @returns {Object}      returns a promise,
     * @since 0.0.0
     */
    PicoQ.get = function(...args) {
      return F.get(...args);
    };

    /**
     * Retrieves a JSON file from the server.
     *
     * @method (arg1, [arg2], [arg3], [arg4])
     * @public
     * @param {String}          the server url,
     * @param {Object}          the fetch options,
     * @param {String}          the type of file (json or text),
     * @param {String}          the function to call at the completion,
     * @returns {Object}        returns a promise,
     * @since 0.0.0
     */
    PicoQ.getJSON = function(...args) {
      return F.getJSON(...args);
    };

    /**
     * Sends a request to the server.
     *
     * @method (arg1, [arg2], [arg3], [arg4])
     * @public
     * @param {String}          the server url,
     * @param {Object}          the fetch options,
     * @param {String}          the type of answer (json or text),
     * @param {String}          the function to call at the completion,
     * @returns {Object}        returns a promise,
     * @since 0.0.0
     */
    PicoQ.post = function(...args) {
      return F.post(...args);
    };


    // -- Public Methods -------------------------------------------------------

    methods = {

      /**
       * Returns the library name and version.
       * (must not be deleted)
       *
       * @method ()
       * @public
       * @param {}            -,
       * @returns {Object}    returns the library name and version,
       * @since 0.0.0
       */
      whoami() {
        return this._library;
      },

      /**
       * Select a child element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the selector,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      select(sel) {
        if (typeof sel === 'string' && this[0]) {
          const child = this[0].querySelector(sel);
          if (child) {
            this[0] = child;
          }
        }
        return this;
      },

      /**
       * Selects the specified child if it exists.
       *
       * @method (arg1)
       * @public
       * @param {Number}        the child index,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      selectChild(n) {
        if (Object.prototype.toString.call(n) === '[object Number]') {
          this[0] = this[0].children[n] ? this[0].children[n] : this[0];
        }
        return this;
      },

      /**
       * Returns to the parent element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      parent() {
        if (this._root) {
          // As a root parent is defined, we stop at it.
          if (this[0] !== this._root) {
            this[0] = this[0].parentNode;
          }
        } else {
          this[0] = this[0].parentNode;
        }
        return this;
      },

      /**
       * Returns to the root parent if defined.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      firstParent() {
        if (this._root) {
          this[0] = this._root;
        }
        return this;
      },

      /**
       * Returns the NodeList of the matching children.
       *
       * @method (arg1)
       * @public
       * @param {String}        the selector,
       * @returns {Array}       returns the NodeList,
       * @since 0.0.0
       */
      find(sel) {
        return this[0].querySelectorAll(sel);
      },

      /**
       * Returns the tag name of the selected element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns the tag name,
       * @since 0.0.0
       */
      tag() {
        return this[0] ? this[0].tagName : null;
      },

      /**
       * Gets/Sets the HTML contents of the element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the html contents to add,
       * @returns {String}      returns the node DOMString or this,
       * @since 0.0.0
       */
      html(xmlString) {
        if (xmlString) {
          this[0].innerHTML = xmlString;
          return this;
        }
        return this[0] ? this[0].innerHTML : '';
      },

      /**
       * Removes all the childs from the current node.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      empty() {
        while (this[0].firstChild) {
          this[0].removeChild(this[0].firstChild);
        }
        return this;
      },

      /**
       * Appends and selects a node, defined by an HTML tag.
       *
       * @method (arg1)
       * @public
       * @param {String}        HTML tage name,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      append(tagName) {
        if (this[0] && typeof tagName === 'string') {
          const element = document.createElement(tagName);
          this[0] = this[0].appendChild(element);
        }
        return this;
      },

      /**
       * Appends a text node child to the selected node.
       *
       * @method (arg1)
       * @public
       * @param {String}        the text to apply,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      appendTextChild(text) {
        if (this[0] && typeof text === 'string') {
          this[0].appendChild(document.createTextNode(text));
        }
        return this;
      },

      /**
       * Appends and selects a node, defined by an HTML tag, before the selected node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        HTML tag name,
       * @param {String}        the selector,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      appendBefore(tagName, node) {
        if (this[0] && typeof tagName === 'string' && typeof node === 'string') {
          const newChild = document.createElement(tagName)
              , child = this[0].querySelector(node)
              ;

          if (child) {
            this[0].insertBefore(newChild, child);
            this[0] = newChild;
          }
        }
        return this;
      },

      /**
       * Appends and selects a node, defined by an HTML tag, after the selected node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        HTML tag name,
       * @param {String}        the selector,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      appendAfter(tagName, node) {
        if (this[0] && typeof tagName === 'string' && typeof node === 'string') {
          const newChild = document.createElement(tagName)
              , child = this[0].querySelector(node)
              ;

          if (child) {
            this[0].insertBefore(newChild, child.nextElementSibling);
            this[0] = newChild;
          }
        }
        return this;
      },

      /**
       * Replaces the current node by a new node defined by an HTML tag.
       *
       * @method (arg1)
       * @public
       * @param {String}        HTML tage name,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      replace(tagName) {
        if (this[0] && typeof tagName === 'string') {
          const element = document.createElement(tagName);
          this[0].parentNode.replaceChild(element, this[0]);
          this[0] = element;
        }
        return this;
      },

      /**
       * Appends an HTML string after the last child of the current node.
       *
       * @method (arg1)
       * @public
       * @param {String}        an HTML string,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      appendHTML(xmlString) {
        if (this[0] && typeof xmlString === 'string') {
          this[0].insertAdjacentHTML('beforeend', xmlString);
        }
        return this;
      },

      /**
       * Appends an HTML string before the first child of the current node.
       *
       * @method (arg1)
       * @public
       * @param {String}        an HTML string,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      prepend(xmlString) {
        if (this[0] && typeof xmlString === 'string') {
          this[0].insertAdjacentHTML('afterbegin', xmlString);
        }
        return this;
      },

      /**
       * Appends an HTML string after the current node.
       *
       * Nota: this method adds a node after the current node only if it is
       * a child node of this component. 'after' is forbidden on the root node.
       *
       * @method (arg1)
       * @public
       * @param {String}        an HTML string,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      after(xmlString) {
        if (this[0] && typeof xmlString === 'string'
          && (!this._root || this[0].id !== this._root.id)) {
          this[0].insertAdjacentHTML('afterend', xmlString);
        }
        return this;
      },

      /**
       * Appends an HTML string before the current node.
       *
       * Nota: this method adds a node before the current node only if it is
       * a child node of this component. 'before' is forbidden on the root node.
       *
       * @method (arg1)
       * @public
       * @param {String}        an HTML string,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      before(xmlString) {
        if (this[0] && typeof xmlString === 'string'
          && (!this._root || this[0].id !== this._root.id)) {
          this[0].insertAdjacentHTML('beforebegin', xmlString);
        }
        return this;
      },

      /**
       * Replaces the current node with the given DOMString.
       *
       * Nota: this method replaces the current node only if it is
       * a child node of this component. 'replaceWith' is forbidden on the root node.
       *
       * @method (arg1)
       * @public
       * @param {String}        an HTML string,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      replaceWith(xmlString) {
        if (!this[0]) return this;

        const oldChild = this[0]
            , parento  = oldChild.parentNode
            , wrapper  = document.createElement('div')
            ;

        if (typeof xmlString === 'string'
          && (!this._root || this[0].id !== this._root.id)) {
          // Replace the old child by new one:
          wrapper.innerHTML = xmlString;
          const newChild = wrapper.firstChild;
          parento.replaceChild(newChild, oldChild);
          this[0] = newChild;
        }
        return this;
      },

      /**
       * Updates the DOM node from the passed-in template.
       *
       * @method (arg1)
       * @public
       * @param {XMLString}     the template,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      diff(XMLString) {
        if (this[0] && typeof XMLString === 'string') {
          D.diff(D.stringToHTML(XMLString), this[0]);
        }
        return this;
      },

      /**
       * Gets/Sets the text contents of the element,
       *
       * @method (arg1)
       * @public
       * @param {String}        the text contents to add,
       * @returns {String}      returns the text contents or this;,
       * @since 0.0.0
       */
      text(texte) {
        if (this[0]) {
          if (typeof texte === 'string') {
            this[0].textContent = texte;
            return this;
          }
          if (texte === undefined) {
            return this[0].textContent;
          }
        }
        return this;
      },

      /**
       * Clones the selected element.
       *
       * @method (arg1)
       * @public
       * @param {Boolean}       true clone with children, false without,
       * @returns {Object}      returns the cloned element,
       * @since 0.0.0
       */
      clone(deep) {
        return (deep === true || deep === false)
          ? this[0].cloneNode(deep)
          : this[0].cloneNode(true);
      },

      /**
       * Returns the firstChild.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the firstChild,
       * @since 0.0.0
       */
      firstChild() {
        return this[0] ? this[0].firstElementChild : this;
      },

      /**
       * Inserts a child element before another child element.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the new node element,
       * @param {Object}        the target node element,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      insertChildBefore(newChild, child) {
        if (this[0] && newChild) {
          this[0].insertBefore(newChild, child);
        }
        return this;
      },

      /**
       * Removes the passed-in child element.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the child element to remove,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      removeChild(child) {
        if (this[0] && child) {
          this[0].removeChild(child);
        }
        return this;
      },

      /**
       * Replaces a child by another.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the new node element,
       * @param {Object}        the node element to replace,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      replaceChild(newChild, child) {
        if (this[0] && newChild) {
          this[0].replaceChild(newChild, child);
        }
        return this;
      },

      /**
       * Returns the children.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the children HTMLCollection,
       * @since 0.0.8
       */
      children() {
        return this[0] ? this[0].children : null;
      },

      /**
       * Returns the children position in the parent tree.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the children position,
       * @since 0.0.8
       */
      childIndex() {
        let child = this[0]
          , index = 0
          ;

        while (child !== null) {
          child = child.previousElementSibling;
          index += 1;
        }
        return index - 1;
      },

      /**
       * Returns the DOMRect object that bounds the contents of the range.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the DOMRect object,
       * @since 0.0.8
       */
      getRect() {
        return this[0] ? this[0].getBoundingClientRect() : null;
      },

      /**
       * Gets/Sets the style attribute of the element,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the style attribute,
       * @param {String}        the style attribute value,
       * @returns {String}      returns the style attribute value or this,
       * @since 0.0.0
       */
      css(styleAttr, value) {
        const arr = typeof styleAttr === 'string' ? styleAttr.split('-') : [];
        let attr = '';

        // Convert style attribute name with '-' (ex.: 'font-size' to 'fontSize'):
        for (let i = 0; i < arr.length; i++) {
          if (i === 0) {
            attr += arr[i];
          } else {
            attr += arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
          }
        }

        if (!value) {
          // Get attribute:
          return this[0] ? this[0].style[attr] : null;
        }

        // Set attribute:
        if (this[0]) {
          this[0].style[attr] = value;
        }
        return this;
      },

      /**
       * Returns the DOMTokenList collection of the class attributes of the element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the DOMTokenList of the element,
       * @since 0.0.0
       */
      getClassList() {
        return this[0] ? this[0].classList : null;
      },

      /**
       * Adds a class name to the element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the class name to add,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      addClass(className) {
        if (this[0] && Object.prototype.toString.call(className) === '[object String]') {
          this[0].classList.add(className);
        }
        return this;
      },

      /**
       * Adds a list of classes to the element.
       *
       * @method (arg1)
       * @public
       * @param {Array}         the list of classes to add,
       * @returns {Object}      returns this,
       * @since 0.0.8
       */
      addClasses(classes) {
        if (this[0] && Array.isArray(classes)) {
          for (let i = 0; i < classes.length; i++) {
            this[0].classList.add(classes[i]);
          }
        }
        return this;
      },

      /**
       * Removes a class name from the element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the class name to remove,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      removeClass(className) {
        if (this[0] && Object.prototype.toString.call(className) === '[object String]') {
          this[0].classList.remove(className);
        }
        return this;
      },

      /**
       * Removes a list of classes from the element.
       *
       * @method (arg1)
       * @public
       * @param {Array}         the list of classes to remove,
       * @returns {Object}      returns this,
       * @since 0.0.8
       */
      removeClasses(classes) {
        if (this[0] && Array.isArray(classes)) {
          for (let i = 0; i < classes.length; i++) {
            this[0].classList.remove(classes[i]);
          }
        }
        return this;
      },

      /**
       * Toggles a class name for the element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the class name to add/remove,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      toggleClass(className) {
        if (this[0] && typeof className === 'string') {
          this[0].classList.toggle(className);
        }
        return this;
      },

      /**
       * Checks if the element has the passed-in class.
       *
       * @method (arg1)
       * @public
       * @param {String}        the class name,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.8
       */
      hasClass(className) {
        const list = this[0] ? this[0].classList.value.split(' ') : [];
        return (Object.prototype.toString.call(className) === '[object String]' && list.indexOf(className) !== -1);
      },

      /**
       * Sets or Gets the specified attribute.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the attribute name,
       * @param {String}        the attribute value,
       * @returns {String}      returns the attribute value or this,
       * @since 0.0.0
       */
      attr(attribute, value) {
        if (this[0] && attribute && value) {
          this[0].setAttribute(attribute, value);
          return this;
        }
        return this[0] ? this[0].getAttribute(attribute) : null;
      },

      /**
       * Removes the specified attribute.
       *
       * @method (arg1)
       * @public
       * @param {String}        the attribute name,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      removeAttr(attribute) {
        if (this[0] && attribute) {
          this[0].removeAttribute(attribute);
        }
        return this;
      },

      /**
       * Performs a custom animation on a set of CSS properties.
       *
       * @method (properties [, duration ] [, easing ] [, complete ])
       * @public
       * @param {Object}        An object of CSS properties,
       * @param {Number}        define how long the animation run,
       * @param {Easing}        the easing animation method,
       * @param {Function}      the function to call at completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      animate(...args) {
        Anim.animate(this, ...args);
        return this;
      },

      /**
       * Attachs an event listener to the current node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the DOM event string,
       * @param {Function}      the listner function,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      on(event, listener) {
        this[0].addEventListener(event, listener);
        return this;
      },

      /**
       * Removes an event listener from the current node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the DOM event string,
       * @param {Function}      the listner function,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      off(event, listener) {
        this[0].removeEventListener(event, listener);
        return this;
      },

      /**
       * Fires the event associated to the selected node.
       *
       * @method (arg1)
       * @public
       * @param {String}        the event name,
       * @returns {Boolean}     returns false if preventDefault was activated
       * @since 0.0.0           otherwise true,
       */
      trigger(event) {
        return this[0].dispatchEvent(new Event(event));
      },

      /**
       * Fires the event associated to the selected node.
       *
       * @method (arg1)
       * @public
       * @param {String}        the event name,
       * @returns {Boolean}     returns false if preventDefault was activated
       * @since 0.0.0           otherwise true,
       */
      fire(event) {
        return this.trigger(event);
      },

      /**
       * Retrieves an XMLString from the server and inserts it into the DOM.
       *
       * @method (arg1, arg2, [arg3], [arg4], [arg5])
       * @public
       * @param {Object}        the PicoQ object,
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      load(...args) {
        return F.loadXML(this, ...args);
      },
    };


    // -- Export
    $__TREE.src.picoq = PicoQ;

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 2, path: 'src/private/animate.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Supplies animation to PicoQ.
     *
     * anim.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _swing                      defines the default easing method,
     *  . _extractArgs                extracts the optional arguments of 'animate',
     *  . _normalizeCssPropertyName   normalizes the CSS properties,
     *  . _getProps                   retrieves the CSS property values,
     *  . _run                        updates dynamically the CSS properties,
     *
     *
     * Public Static Methods:
     *  . animate                     performs a custom animation,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Defines a few utilities to test the variable types.
     */
    const _ = {
      isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
      },

      isNumber(obj) {
        return Object.prototype.toString.call(obj) === '[object Number]';
      },

      isFunction(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
      },

      isLiteralObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
      },
    };

    /**
     * Defines the default easing method.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Number}          the current lapse time,
     * @param {Number}          the initial CSS property value,
     * @param {Number}          the difference between the final and the initial value,
     * @param {Number}          the animation duration,
     * @returns {Number}        returns the value of the CSS property at the current
     * @since 0.0.0             lapse time,
     */
    /* eslint-disable no-mixed-operators */
    function _swing(t, b, c, d) {
      return c * (0.5 - Math.cos(t / d * Math.PI) / 2) + b;
    } /* eslint-enable no-mixed-operators */

    /**
     * Extracts the optional arguments of 'animate'.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {?}               duration, easing or callback,
     * @param {?}               easing or callback,
     * @param {Object}          the function to call at completion,
     * @returns {Object}        returns an object with the properties duration,
     *                          easing, and callback,
     * @since 0.0.0
     */
    function _extractArgs(...args) {
      const op1 = args[0]
          , op2 = args[1]
          , op3 = args[2]
          ;

      let nargs
        , duration
        , easing
        , callback
        ;

      // How many optional arguments?
      if (!op1 && !op2 && !op3) {
        nargs = 0;
      } else if (op1 && !op2 && !op2) {
        nargs = 1;
      } else if (op1 && op2 && !op3) {
        nargs = 2;
      } else {
        nargs = 3;
      }

      switch (nargs) {
        case 0:
          break;

        case 1:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
          } else if (_.isString(op1)) {
            easing = op1;
          } else if (_.isFunction(op1)) {
            callback = op1;
          }
          break;

        case 2:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
            if (_.isString(op2)) {
              easing = op2;
            } else if (_.isFunction(op2)) {
              callback = op2;
            }
          } else if (_.isString(op1)) {
            easing = op1;
            if (_.isFunction(op2)) {
              callback = op2;
            }
          }
          break;

        case 3:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
          }
          if (_.isString(op2)) {
            easing = op2;
          }
          if (_.isFunction(op3)) {
            callback = op3;
          }
          break;

        default:
          break;
      }

      return {
        duration,
        easing,
        callback,
      };
    }

    /**
     * Normalizes the CSS properties.
     * (replace '-' between composite name by camelcase style).
     * Ex: font-size -> fontSize
     *
     * @function (arg1)
     * @private
     * @param {String}          the CSS property name,
     * @returns {String}        the normalized CSS property name,
     * @since 0.0.0
     */
    function _normalizeCssPropertyName(name) {
      const arr = _.isString(name) ? name.split('-') : []
          ;

      // Convert name with '-' (ex.: 'font-size' to 'fontSize'):
      let normalized = '';
      for (let i = 0; i < arr.length; i++) {
        if (i === 0) {
          normalized += arr[i];
        } else {
          normalized += arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
        }
      }
      return normalized;
    }

    /**
     * Retrieves the CSS property values for the given node.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the given node,
     * @param {Object}          the CSS properties to animate,
     * @returns {Object}        returns an object with the properties initial,
     * @since 0.0.0             change, suffix, per animated property,
     */
    function _getProps(el, properties) {
      const keys  = Object.keys(properties)
          , style = window.getComputedStyle(el)
          , props = {}
          , names = []
          ;

      let name
        , cssValue
        , cssParent
        , suffix
        ;

      // Parse the properties:
      for (let i = 0; i < keys.length; i++) {
        // Normalize the name of the property:
        name = _normalizeCssPropertyName(keys[i]);
        // Check it is a valid CSS property:
        cssValue = style.getPropertyValue(name);
        if (cssValue) {
          names.push(name);
          cssValue = parseFloat(cssValue, 10);
          suffix = properties[keys[i]].replace(/[0-9.]/g, '');
          // Absolute or relative?
          if (suffix === '%') {
            // Relative, convert pixel value returned by 'getComputedStyle' in %:
            cssParent = parseFloat(
              window.getComputedStyle(el.parentNode).getPropertyValue(name),
            );
            cssValue = (cssValue / cssParent) * 100;
          }
          props[name] = {
            initial: cssValue,
            change: parseFloat(properties[keys[i]]) - cssValue,
            suffix,
          };
        }
      }
      props.name = names;
      return props;
    }

    /**
     * Updates dynamically the CSS properties from their initial value to their final.
     *
     * @function (arg1, arg2, arg3, arg4, arg5, arg6)
     * @private
     * @param {Object}          the given node,
     * @param {Object}          the CSS properties to update,
     * @param {Function}        the easing method,
     * @param {Number}          the animation duration,
     * @param {Number}          the animation step,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _run(el, properties, easing, duration, delay, callback) {
      const props = _getProps(el, properties)
          , elem = el
          ;

      let lapseOfTime = 0
        , value
        ;

      const timer = setInterval(() => {
        // easing:
        for (let i = 0; i < props.name.length; i++) {
          value = easing(
            lapseOfTime,
            props[props.name[i]].initial,
            props[props.name[i]].change,
            duration,
          );
          elem.style[props.name[i]] = value + props[props.name[i]].suffix;
        }
        lapseOfTime += delay;
        if (lapseOfTime > duration) {
          clearInterval(timer);
          if (callback) callback();
        }
      }, delay);
    }


    // -- Public Static Methods ------------------------------------------------

    const Anim = {

      /**
       * Performs a custom animation on a set of CSS properties.
       *
       * @method (properties [, duration ] [, easing ] [, complete ])
       * @public
       * @param {Object}        an object of CSS properties,
       * @param {Number}        define how long the animation run,
       * @param {Easing}        the easing animation method,
       * @param {Function}      the function to call at completion,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      animate(node, properties, ...args) {
        const DTIME = 400
            , FAST  = 200
            , SLOW  = 600
            , INC   = 10
            , delay = INC
            ;


        // Is the argument properties an object?
        if (!_.isLiteralObject(properties)) {
          return this;
        }

        // Extract the optional arguments:
        const argu = _extractArgs(...args);

        // Set the duration:
        const duration = _.isNumber(argu.duration) && argu.duration > 0
          ? argu.duration
          : (function(arg) {
            if (arg === 'fast') return FAST;
            if (arg === 'slow') return SLOW;
            return DTIME;
          }(argu.duration));

        // Set the easing (swing only for the time being):
        const easing = (window.Easing && window.Easing[argu.easing])
          ? window.Easing[argu.easing]
          : _swing;

        // Set the callback:
        const callback = argu.callback ? argu.callback : null;

        // Run the animation:
        _run(node[0], properties, easing, duration, delay, callback);

        // For testing purpose:
        /* eslint-disable-next-line no-param-reassign */
        node._probe = {
          duration,
          easing: (window.Easing && window.Easing[args.easing]) ? args.easing : 'swing',
          callback,
        };

        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.animate, Anim);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 3, path: 'src/private/fetch.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Retrieves data from the server.
     *
     * fetch.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the named fetch arguments,
     *  . _fetch                      fetches data on the server,
     *
     *
     * Public Static Methods:
     *  . fetch                       fetches data on the server,
     *  . get                         retrieves a text file from the server,
     *  . getJSON                     retrieves a JSON file from the server,
     *  . post                        sends a request to the server,
     *  . load                        retrieves data from the server,
     *  . loadXML                     retrieves an XMLString and add it into the DOM,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the named fetch arguments.
     *
     * @function (...args)
     * @private
     * @param {...}             the optional arguments [url, options, type, callback],
     * @returns {}              -,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;

      switch (args.length) {
        case 0:
          return [null, null, null, null];

        case 1:
          if (typeof arg1 === 'string') {
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 2:
          if (typeof arg1 === 'string') {
            if (typeof arg2 === 'object' && arg2.method) {
              return [arg1, arg2, null, null];
            }
            if (typeof arg2 === 'string') {
              return [arg1, {}, arg2, null];
            }
            if (typeof arg2 === 'function') {
              return [arg1, {}, null, arg2];
            }
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 3:
          if (typeof arg1 === 'string') {
            if (typeof arg2 === 'object' && arg2.method) {
              if (typeof arg3 === 'string') {
                return [arg1, arg2, arg3, null];
              }
              if (typeof arg3 === 'function') {
                return [arg1, arg2, null, arg3];
              }
              return [arg1, arg2, null, null];
            }

            if (typeof arg2 === 'string') {
              if (typeof arg3 === 'function') {
                return [arg1, {}, arg2, arg3];
              }
              return [arg1, {}, arg2, null];
            }

            if (typeof arg3 === 'function') {
              return [arg1, {}, null, arg3];
            }
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 4:
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string'
            && typeof arg4 === 'function') {
            return [arg1, arg2, arg3, arg4];
          }
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string') {
            return [arg1, arg2, arg3, null];
          }
          return [null, null, null, null];

        default:
          // > 4
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string'
            && typeof arg4 === 'function') {
            return [arg1, arg2, arg3, arg4];
          }
          return [null, null, null, null];
      }
    }

    /**
     * Fetches data on the server.
     *
     * Nota:
     * By default, fetch returns text data. If you want to return json data, you
     * have to pass the argument 'json'. For instance, to get a json file from
     * the server:
     *  . Fetch('/', 'json', (json) => {
     *      //
     *   })
     *
     * @function (...args)
     * @public
     * @param {...}             the optional arguments [url, options, type, callback],
     * @returns {}              -,
     * @since 0.0.0
     */
    function _fetch(url, options, type, callback) {
      fetch(url, options)
        .then((resp) => {
          if (resp.ok) {
            return type === 'json' ? resp.json() : resp.text();
          }
          return Promise.reject(resp);
        })
        .then((data) => {
          if (callback) {
            callback(null, data);
          } else {
            /* eslint-disable-next-line no-console */
            console.log('warning: fetch gets no callback!');
          }
        })
        .catch((err) => {
          if (callback) {
            callback(err);
          } else {
            /* eslint-disable-next-line no-console */
            console.log('warning: fetch gets no callback!');
          }
        });
    }


    // -- Public Static Methods ------------------------------------------------

    const Fetch = {

      /**
       * Returns the named fetch arguments.
       * (for testing purpose only)
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      _getArgs(...args) {
        return _getArgs(...args);
      },

      /**
       * Fetches data on the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      fetch(...args) {
        const [url, options, type, callback] = _getArgs(...args);
        return new Promise((resolve, reject) => {
          _fetch(url, options, type, (err, data) => {
            if (err) {
              reject(err);
            } else {
              resolve(data);
            }
            if (callback) callback(err, data);
          });
        });
      },

      /**
       * Retrieves a text file from the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      get(...args) {
        const [url,,, callback] = _getArgs(...args);
        return this.fetch(url, { method: 'GET' }, 'text', callback);
      },

      /**
       * Retrieves a JSON file from the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      getJSON(...args) {
        const [url,,, callback] = _getArgs(...args);
        return this.fetch(url, { method: 'GET' }, 'json', callback);
      },

      /**
       * Sends a request to the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of answer (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      post(...args) {
        return this.fetch(...args);
      },

      /**
       * Fetches data from the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      load(...args) {
        const [url,, type, callback] = _getArgs(...args);
        return this.fetch(url, { method: 'GET' }, type, callback);
      },

      /**
       * Retrieves an XMLString from the server and inserts it into the DOM.
       * (specific to PicoQ)
       *
       * @method (arg1, arg2, [arg3], [arg4], [arg5])
       * @public
       * @param {Object}        the PicoQ object,
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      loadXML(picoq, ...args) {
        const [url,,, callback] = _getArgs(...args);

        return new Promise((resolve, reject) => {
          _fetch(url, { method: 'GET' }, 'text', (err, data) => {
            if (err) {
              reject(err);
            } else {
              if (picoq[0]) picoq.html(data);
              resolve(data);
            }
            if (callback) callback(err, data);
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.fetch, Fetch);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 4, path: 'src/private/diffing.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Updates a DOM node with the passed in 'virtual' node.
     *
     * It updates only the elements that have attributes or contents that
     * differ from the passed-in HTML node.
     *
     * diff is free interpretation of:
     *  - https://gomakethings.com/dom-diffing-with-vanilla-js/
     *
     * diffing.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     *
     * Private Functions:
     *  . _stringToHTML               converts an XML String to an HTML object,
     *  . _getNodeType                returns the tag name,
     *  . _getNodeContent             returns the element content,
     *  . _updateAttributes           updates the target attrs to match the source attrs,
     *  . _diff                       updates the outdated elements of the DOM node,
     *
     *
     * Public Static Methods:
     *  . stringToHTML                converts an XML String to an HTML object,
     *  . diff                        updates the outdated elements of the DOM node,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Converts an XML String to an HTML object.
     *
     * @function (arg1)
     * @private
     * @param {XMLString}       the XML string to convert,
     * @returns {Object}        returns the HTML object,
     * @since 0.0.0
     */
    function _stringToHTML(str) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(str, 'text/html');
      return doc.body.firstChild;
    }

    /**
     * Returns the tag name.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the node,
     * @returns {String}        returns the tag name,
     * @since 0.0.0
     */
    function _getNodeType(node) {
      if (node.nodeType === 3) return 'text';
      if (node.nodeType === 8) return 'comment';
      return node.tagName.toLowerCase();
    }

    /**
     * Returns the element content.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the node,
     * @returns {String}        returns the element content,
     * @since 0.0.0
     */
    function _getNodeContent(node) {
      if (node.children && node.children.length > 0) return null;
      return node.textContent;
    }

    /**
     * Updates the target attributes to match the source attributes.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the reference element,
     * @param {Object}          the DOM element,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _updateAttributes(node, elem) {
      const nodeAttrs = node.getAttributeNames();
      const elemAttrs = elem.getAttributeNames();

      // Parse all the source attributes and update the target attributes
      // accordingly.
      for (let i = 0; i < nodeAttrs.length; i++) {
        const nodeAttr = nodeAttrs[i];
        const elemAttr = elem.attributes.getNamedItem(nodeAttr);
        const nodeAttrValue = node.getAttribute(nodeAttr);
        const elemAttrValue = elem.getAttribute(nodeAttr);
        if (!elemAttr || (elemAttrValue !== nodeAttrValue)) {
          // Ok the DOM element hasn't the attribute or its value is
          // outdated, set it:
          // console.log(`set attribute: ${nodeAttr} with the value: ${nodeAttrValue}`);
          elem.setAttribute(nodeAttr, nodeAttrValue);
        }
      }

      // Remove the extra target attributes.
      for (let i = 0; i < elemAttrs.length; i++) {
        if (nodeAttrs.indexOf(elemAttrs[i]) === -1) {
          // console.log(`${elemAttrs[i]} is an extra attribute!`);
          elem.removeAttribute(elemAttrs[i]);
        }
      }
    }

    /**
     * Updates the outdated elements of the DOM node.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the reference node,
     * @param {Object}          the DOM node,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _diff(source, target) {
      // Get arrays of children nodes
      const sourceNodes = Array.prototype.slice.call(source.children);
      const domNodes = Array.prototype.slice.call(target.children);

      // If there are extra elements in DOM, remove them
      let count = domNodes.length - sourceNodes.length;
      if (count > 0) {
        for (; count > 0; count--) {
          /* eslint-disable-next-line max-len */
          domNodes[domNodes.length - count].parentNode.removeChild(domNodes[domNodes.length - count]);
        }
      }

      // Diff each item in the templateNodes
      sourceNodes.forEach((node, index) => {
        // If the element doesn't exist in the DOM, create it:
        if (!domNodes[index]) {
          target.appendChild(node.cloneNode(true));
          return;
        }

        // If element is not the same type, replace it with the new element:
        if (_getNodeType(node) !== _getNodeType(domNodes[index])) {
          domNodes[index].parentNode.replaceChild(node.cloneNode(true), domNodes[index]);
          return;
        }

        // If the content is different, update it:
        const sourceContent = _getNodeContent(node);
        if (sourceContent && sourceContent !== _getNodeContent(domNodes[index])) {
          domNodes[index].textContent = sourceContent;
        }

        // If the attributes are different update them:
        if (node.hasAttributes() || domNodes[index].hasAttributes()) {
          _updateAttributes(node, domNodes[index]);
        }

        // If the target element should be empty, wipe it
        if (domNodes[index].children.length > 0 && node.children.length < 1) {
          domNodes[index].innerHTML = '';
          return;
        }

        // If element is empty and shouldn't be, build it up.
        // This uses a document fragment to minimize reflows
        if (domNodes[index].children.length < 1 && node.children.length > 0) {
          const fragment = document.createDocumentFragment();
          _diff(node, fragment);
          domNodes[index].appendChild(fragment);
        }

        // If there are existing child elements that need to be modified, diff them
        if (node.children.length > 0) {
          _diff(node, domNodes[index], true);
        }
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Differ = {

      /**
       * Converts an XML String to an HTML object.
       *
       * @method (arg1)
       * @public
       * @param {XMLString}     the XML string to convert,
       * @returns {Object}      returns the HTML object,
       * @since 0.0.0
       */
      stringToHTML(str) {
        return _stringToHTML(str);
      },

      /**
       * Updates the outdated elements of the DOM node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the reference node,
       * @param {Object}        the DOM node,
       * @since 0.0.0
       */
      diff(source, target) {
        return _diff(source, target);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.diffing, Differ);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());


  // Returns the library name:
  return $__TREE.src.picoq;
}));
